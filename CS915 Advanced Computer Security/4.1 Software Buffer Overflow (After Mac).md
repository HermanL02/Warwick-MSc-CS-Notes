# Memory Allocation
Stack: High to Low
Heap: Low to High
Heap overflow resulting stack smashing

# Program memory stack
From Low to High:
1. Text segment: Executable code of the program
2. Data segment: Static/Global variables that are initialized by the programmer
3. Block Started by Symbol, (BSS) segment: uninitialized static/global variables
4. Heap: Dynamic memory allocation
5. Stack: Local variables defined inside functions, data related to functions calls (ex. return address, argumnets)
## Example Code
![Code Example](https://lh7-us.googleusercontent.com/8-mHCZn5ONQ0RzZrvggapaNWc2S9JnIsvRBoR3j6vBLjkCUKzcrJeWssFKmW3YZrUGtswxvBRnxuB2EXY3a-nI-rJ1VV2wDjU8ANoUzyAD8XaueCi5ZuYmxqz57aMKFQuXXLJ6epJcSaAjjJfJTStaHj=s2048)
x: Data Segment
y: BSS segment
ptr: Heap
a, b, ptr: Stack

## Stack memory layout
Suppose: 
void func(int a, int b){
	int x , y;
	x = a + b;
	y = a - b;
}
### Stack:  From High to Low
Value of b
Value of a
Return Addr
Previous Frame Pointer
Value of x
Value of y
==Explained How assembly code works==

### Function inside function
a(), b(), c()
b is  inside a, c is inside b

Stack: From High address to low address
a()
b()
c()

After each function is executed, the corresponding stack will be released. 

### Why stack overflow dangerous? Ex. Copy a String in C
strcpy() only copies the string before `\0`
`char a[40] = "Hello world \0 Extra string"`
strcpy(b, a) only copies "Hello world" to b

### Example of copy buffer overflow
```
void foo(char *str*){
	char b[12].
	strcpy(buffer, str)
}
If str is larger than 12, it will cause a overflow
```
It would influence higher level parts, like return Address, pointer as shown here.  [[4.1 Software Buffer Overflow (After Mac)#Stack From High to Low]]


## How Malicious Input works
Task A: Find the distance between the base of the buffer and return address
Task B: Find the address to place the malicious code (e.g., shellcode)
Random guess: Takes 2^32 times attempt to find the correct address; 
**So, how to make it more possible to help attackers find the right address?** 
### Technique 1: Fill NOP
### spraying return address

Hard to calculate, because compiler might add some bytes



